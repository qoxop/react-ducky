---
sidebar_position: 2
---

# 示例: 待办列表

这一节，我们通过创建一个 TodoList 应用来快速熟悉一下 React-Ducky 的基础用法。

:::note
假设前置的安装和初始化都已经完成了，所以我们直接从具体的模块开始编写 Demo
:::

## 一、分析

**首先，**我们先确认一个待办需要包含哪些信息:
- 唯一ID
- 标题内容
- 到期时间
- 完成状态

**其次，**我们要明确待办列表的功能点(对应数据的操作):
- **新增**一个待办
- **删除**一个待办
- **修改**一个待办
  - 反转完成状态
  - 修改内容和时间
- **查看**筛选待办列表

## 二、创建数据模型

基本上就是定义数据的类型以及对数据的操作方法: 

```ts title='model.ts' {19-45}
import { 
  createModel, 
  PayloadAction
} from 'React-Ducky';

export type TodoItem = {
  id: string,
  title: string;
  expired: string;
  finished: boolean;
}

const todoModel = createModel({
  statePaths: ['todo'],
  initialState: {
    list: [] as TodoItem[],
  },
  reducers: {
    toggle: (state, action: PayloadAction<string>) => {
      const index = state.list.findIndex(item => item.id === action.payload);
      if (index > -1) {
        state.list[index].finished = !state.list[index].finished;
      }
    },
    add: (state, action: PayloadAction<TodoItem>) => {
      state.list.unshift({
        ...action.payload,
        id: Mock.Random.guid(),
      });
    },
    update: (state, action: PayloadAction<TodoItem>) => {
      const { payload: newTodo } = action;
      const index = state.list.findIndex(item => item.id === newTodo.id);
      if (index > -1) {
        state.list[index] = newTodo;
      } else {
        state.list.unshift(newTodo)
      }
    },
    del: (state, action:PayloadAction<string>) => {
      state.list = state.list.filter(item => item.id !== action.payload)
    },
    clear: (state) => {
      state.list = [];
    }
  }
});
```

## 三、使用数据模型

### 1、更新 reducer

`model` 对象上有个 `reducer` 方法，我们需要通过 [`combineReducers`](http://cn.redux.js.org/api/combinereducers) 将它合并到 redux 的**根 `reducer`** 上。

在这个例子中，我们通过 `initStore` 返回的 `updateReducer` 方法来实现合并的过程：

```ts title='model.ts'
import { updateReducer } from 'src/provider';
// createModel ....
updateReducer({ todo: todoModel.reducer });

export default todoModel;
```

### 2、在组件订阅模型数据

通过 model 对象上的 `useModel` 方法可以订阅到模型数据。

```tsx {5}
import React from 'react';
import todoModel from './model';

export const TodoList = () => {
  const todoList = todoModel.useModel((state) => state.list);
  return (/* render todoList */)
}
```

### 3、将更新方法传递给组件

**不需要 `connect`, 也不需要 `dispatch`**。`todoModel.actions` 对象上的方法内部会自行调用 `dispatch` 方法来触发一个 redux 的动作，从而达到修改数据的目的。

```tsx title="将 todoModel 的增删改方法直接传递给UI组件" {10,15-17}
import React from 'react';
import todoModel from './model';
import { Todo } from './components/todo-item';
import { TodoEditor } from './components/todo-editor';

export const TodoList = () => {
  const todoList = todoModel.useModel((state) => state.list);
  return (
    <div>
      <TodoEditor onSave={todoModel.actions.add} />
      {todoListWithFilter.map(item => (
            <Todo
              key={item.id}
              data={item}
              onToggle={todoModel.actions.toggle}
              onUpdate={todoModel.actions.update}
              onDelete={todoModel.actions.del}
            />
          )
        )}
    </div>
  )
}
```

:::info
_**model.actions**_ 包含的方法与传入的 _**reducers**_ 一一对应，_**actions**_ 方法的参数类型由 _**reducer**_ 方法**自动推导**得出。
比如: 
_**reducers.toggle**_ 的类型为 `(state, action: PayloadAction<string>) => void`，推导出 
**actions.toggle** 的类型为 `(arg: string) => void`
:::

到此，除了布局样式和具体的UI组件外，我们已经完成了所有业务逻辑的编写。[查看完整示例代码](https://github1s.com/qoxop/React-Ducky/blob/main/websites/demo/src/pages/todo/model.ts)


## 四、使用持久化存储

为了让我们的数据再能持久化保存，我们可以使用相关的缓存配置:

```ts title='model.ts' {8-10}
// .... 
export default createModel({
  statePaths: ['todo'],
  initialState: {
    list: [] as TodoItem[],
  },
  reducers: { /*...*/ },
  cacheKey: 'my-todo-model',
  cacheStorage: 'local',
  cacheVersion: 'v1',
});
```

## 五、最终效果

<iframe
  src="https://React-Ducky.qoxop.run/demo#/todo/list"
  className="todo_demo"
></iframe>


